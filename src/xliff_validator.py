"""
KLMS XLIFF 2.0 Validator v7

This is a validation pipeline for XLIFF 2.0 files for the KLMS project.
It is used as a check against producing invalid XLIFF files, and ensures any generated XLIFF 
files are compliant to the requirements. It is very important to note that in these files (due to 
limitations of some of the tools that generate and read these files, and also due to making it 
super-easy to use with visual diff tools like Beyond Compare), everything matters: whitespace, newlines, 
formatting, case, structure. So, when generating a file or doing translation, the spacing, indentions, 
trailing whitespace, newlines, case , etc must match the English master exactly, and any generated 
target must match the source structure and format exactly. So this validation pipeline checks to this
very strict level of compliance.
"""

import os
import sys
import inspect
import argparse
import traceback
from utils import Config
from utils import read_file_lines
from utils import ValidationIssue
from checks import ALL_SINGLE_FILE_CHECKS, ALL_FILE_PAIR_CHECKS

def validate_xliff_file(filepath):
    """
    ChatGPT Entry Point for Single File Validation

    ChatGPT's has access to files at the project level, and their paths are like /mnt/data/klms8-messages(es).xlf 
    So ChatGPT should use this function for single file validation. For generated files, they should 
    be written to /mnt/data before invoking these methods. The array of validation issues returned by these methods 
    can be used to render the results in the UI, or be used by ChatGPT to analyze what went wrong with it's generation 
    code and try to fix the issues. This validation should be run on any XLIFF file generated by ChatGPT before the 
    file is brought to the user's attention for review. This prevents wasting the user's time reviewing incorrect results.
    If ChatGPT generates a file and it fails these checks, it should use this validation output to diagnose it's code 
    and resolve it. ChatGPT should continuously fix and validate in a cycle until a correct result is produced, or it 
    gives up and needs user assistance in helping to resolve what is wrong because it ran of out ideas on how to fix 
    the code to resolve the issues reported by this pipeline.

    Returns a list of ValidationIssue objects, or an empty list if no validation issues were found.
    """
    print(f"Validating XLIFF file: {filepath}")

    # Run binary-only checks first (e.g., UTF-8 BOM)
    for check in ALL_SINGLE_FILE_CHECKS:
        parameter_count = len(inspect.signature(check).parameters);
        if parameter_count == 1:
            issues = check(filepath)
            if issues:
                return issues

    filename = os.path.basename(filepath)
    lines = read_file_lines(filepath)

    for check in ALL_SINGLE_FILE_CHECKS:
        parameter_count = len(inspect.signature(check).parameters);
        if parameter_count != 1:
            issues = check(filename, lines)
            if issues:
                return issues

    return []

def validate_xliff_file_pair(master_filepath, translated_filepath):
    """
    ChatGPT Entry Point for File Pair Validation (Master XLIFF and a translated language XLIFF)

    ChatGPT's has access to files at the project level, and their paths are like /mnt/data/klms8-messages(es).xlf 
    So ChatGPT should use this function for validating a translated file against the English master
    it is based on. See the docstring comments in validate_xliff_file() for more info.
    
    Returns a list of ValidationIssue objects, or an empty list if no validation issues were found.
    """

    print(f"Validating XLIFF file: {translated_filepath} against master {master_filepath}")

    english_filename = os.path.basename(master_filepath)
    issues = validate_xliff_file(master_filepath)
    if issues:
        return issues

    translated_filename = os.path.basename(translated_filepath)
    issues = validate_xliff_file(translated_filepath)
    if issues:
        return issues

    master_lines = read_file_lines(master_filepath)
    translated_lines = read_file_lines(translated_filepath)

    for check in ALL_FILE_PAIR_CHECKS:
        issues = check(english_filename, master_lines, translated_filename, translated_lines)
        if issues:
            return issues

    return []

def main():
    """
    User Entry Point

    This code has no external dependencies and is standalone. It can be run as a program which calls the main() 
    method and as arguments accepts one file path or two. If one file, it will run the single XLIFF file validation 
    checks; if two files are specified it will run the file pair validation checks (which include the single file 
    checks).
    """
    issues = []
    
    try:
        parser = argparse.ArgumentParser(description="Validate XLIFF files.")
        parser.add_argument("files", nargs='+', help="List of XLIFF files. Pass one for single file validation, two for file pair validation.")
        args = parser.parse_args()

        if len(args.files) == 1:
            issues = validate_xliff_file(args.files[0])
        elif len(args.files) == 2:
            issues = validate_xliff_file_pair(args.files[0], args.files[1])
        else:
            print("Usage: python xliff_validator.py <file.xlf> OR <english.xlf> <translated.xlf>")
            return

        if issues:
            print(f"\nFound {len(issues)} validation issue(s):\n")
            print(ValidationIssue.table_header())
            for issue in issues:
                print(issue.format_as_table_row())
            print(ValidationIssue.table_footer())
        else:
            print("No validation issues found")

    except Exception:
        print("\nException during validation:")
        traceback.print_exc()

if __name__ == "__main__":
    sys.argv = ["xliff_validator.py", os.path.join(Config.TEST_FILES_PATH, "klms8-messages(en).xlf"), os.path.join(Config.TEST_FILES_PATH, "klms8-messages(es).xlf")]
    #sys.argv = ["xliff_validator.py", os.path.join(Config.TEST_FILES_PATH, "MCB_OTPS_L01_Storyline(en).xlf"), os.path.join(Config.TEST_FILES_PATH, "MCB_OTPS_L01_Storyline(es).xlf")]
    sys.argv = ["xliff_validator.py", os.path.join(Config.TEST_FILES_PATH, "MCB_OTPS_L01_Storyline(en).xlf")]
    main()
